이 프로그램 인 mlfq.py를 사용하면 MLFQ 스케줄러가
이 장에 제시된대로 작동합니다. 이전과 같이, 이것을 사용하여
임의의 씨앗을 사용하거나 직접 구성하여
MLFQ가 다른 환경에서 어떻게 작동하는지보기 위해 신중하게 설계된 실험
상황. 프로그램을 실행하려면 다음을 입력하십시오.

프롬프트> ./mlfq.py

옵션을 보려면 help 플래그 (-h)를 사용하십시오.

사용법 : mlfq.py [옵션]
옵션 :./
  -h, --help이 도움말 메시지를 표시하고 종료
  -s SEED, --seed = 임의의 시드
  -n NUMQUEUES, --numQueues = NUMQUEUES
                        MLFQ의 큐 수 (-Q를 사용하지 않는 경우)
  -q QUANTUM, --quantum = QUANTUM
                        시간 조각 길이 (-Q를 사용하지 않는 경우)
  -Q QUANTUMLIST, --quantumList = QUANTUMLIST
                        큐 레벨 당 시간 조각 길이
                        x, y, z, ...로 지정됩니다. 여기서 x는
                        최고 우선 순위의 양자 길이
                        대기열, y 다음 최고 등
  -j NUMJOBS, --numJobs = NUMJOBS
                        시스템의 작업 수
  -m MAXLEN, --maxlen = MAXLEN
                        작업의 최대 런타임 (임의의 경우)
  -M MAXIO, --maxio = MAXIO
                        작업의 최대 I / O 빈도 (임의의 경우)
  -B BOOST, --boost = BOOST
                        모든 사람의 우선 순위를 높이는 빈도
                        우선 순위가 높은 작업 (0은 절대 사용하지 않음)
  -i IOTIME, --iotime = IOTIME
                        I / O 지속 시간 (고정 상수)
  -S,-재설정 상태 유지 및 동일한 우선 순위 수준 유지
                        I / O를 발행 할 때
  -l JLIST, --jlist = JLIST
                        쉼표로 구분 된 실행할 작업 목록
                        x1, y1, z1 : x2, y2, z2 : ... 형식으로
                        x는 시작 시간이고, y는 런타임이며, z
                        작업이 I / O 요청을 발행하는 빈도입니다.
  -c 나에게 ​​답을 계산해라
]

시뮬레이터를 사용하는 몇 가지 방법이 있습니다. 한 가지 방법은 생성하는 것입니다
임의의 작업을 수행하고 그들이 어떻게 작동하는지 알아낼 수 있는지 확인하십시오.
MLFQ 스케줄러. 예를 들어 무작위로 생성 한 경우
세 가지 작업을 수행하려면 다음과 같이 입력하십시오.

프롬프트> ./mlfq.py -j 3

그러면 다음과 같은 특정 문제 정의가 나타납니다.

입력 목록은 다음과 같습니다.
옵션 작업 3
옵션 대기열 3
대기열 2의 옵션 양자 길이는 10입니다.
옵션 대기열 1의 양자 길이는 10입니다.
옵션 큐 0의 양자 길이는 10입니다.
옵션 부스트 0
옵션 ioTime 0
옵션 후 AfterIO False


각 작업에 대해 세 가지 정의 특성이 제공됩니다.
  startTime : 작업이 시스템에 들어가는 시간
  runTime : 작업 완료에 필요한 총 CPU 시간
  ioFreq : 모든 ioFreq 시간 단위에서 작업이 I / O를 발행 함
              (I / O는 ioTime 장치를 완료하는 데 소요됩니다)

직업 목록 :
  작업 0 : startTime 0-런타임 84-ioFreq 7
  작업 1 : startTime 0-런타임 42-ioFreq 2
  작업 2 : startTime 0-런타임 51-ioFreq 4

주어진 워크로드에 대한 실행 추적을 계산하십시오.
원하는 경우 응답과 처리 시간도 계산하십시오.
각 작업에 대한 시간.

완료되면 정확한 결과를 얻으려면 -c 플래그를 사용하십시오.

이렇게하면 기본값에 따라 세 가지 작업 (지정된대로)의 임의 워크로드가 생성됩니다.
여러 기본 설정이있는 대기열 수 당신이 다시 실행하면
(-c)의 플래그를 해결하면 위와 동일한 인쇄물과
수행원:

실행 추적 :

[시간 0] JOB 0에 의한 JOB BEGINS
[시간 0] JOB 1에 의해 JOB BEGINS
[시간 0] JOB 2에 의한 JOB BEGINS
[시간 0] 우선 순위 2에서 JOB 0 실행 [TICKS 9 ALLOT 1 TIME 83 (의 84)]
[시간 1] 우선 순위 2에서 JOB 0 실행 [TICKS 8 ALLOT 1 TIME 82 (의 84)]
[시간 2] 우선 순위 2에서 JOB 0 실행 [TICKS 7 ALLOT 1 TIME 81 (의 84)]
[시간 3] 우선 순위 2에서 JOB 0 실행 [TICKS 6 ALLOT 1 TIME 80 (의 84)]
[시간 4] 우선 순위 2에서 JOB 0 실행 [TICKS 5 ALLOT 1 TIME 79 (의 84)]
[시간 5] 우선 순위 2에서 JOB 0 실행 [TICKS 4 ALLOT 1 TIME 78 (의 84)]
[시간 6] 우선 순위 2에서 JOB 0 실행 [TICKS 3 ALLOT 1 TIME 77 (의 84)]
[시간 7] JOB 0에 의한 IO_START
IO 완료
[시간 7] 우선 순위 2에서 JOB 1 실행 [TICKS 9 ALLOT 1 TIME 41 (의 42)]
[시간 8] 우선 순위 2에서 JOB 1 실행 [TICKS 8 ALLOT 1 TIME 40 (의 42)]
[시간 9] 우선 순위 2에서 JOB 1 실행 [TICKS 7 ALLOT 1 TIME 39 (의 42)]
...

최종 통계 :
  작업 0 : 시작 시간 0-응답 0-처리 시간 175
  작업 1 : 시작 시간 0-응답 7-처리 191
  작업 2 : 시작 시간 0-응답 9-처리 168

  평균 2 : 시작 시간 해당 없음-응답 5.33-처리 시간 178.00
]

추적은 밀리 초 단위의 시간 단위로 정확하게 무엇을 보여줍니다.
스케줄러가 결정했습니다. 이 예에서는 작업 0을 7ms 동안 실행하여 시작합니다.
작업 0이 I / O를 발행 할 때까지; 이것은 Job 0의 I / O로서 완전히 예측 가능합니다.
주파수는 7ms로 설정됩니다. 즉, 7ms가 실행될 때마다
계속하기 전에 I / O 및 완료 될 때까지 기다리십시오. 그 시점에서
스케줄러가 실행되는 작업 1로 전환