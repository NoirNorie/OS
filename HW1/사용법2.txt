추적은 밀리 초 단위의 시간 단위로 정확하게 무엇을 보여줍니다.
스케줄러가 결정했습니다. 이 예에서는 작업 0을 7ms 동안 실행하여 시작합니다.
작업 0이 I / O를 발행 할 때까지; 이것은 Job 0의 I / O로서 완전히 예측 가능합니다.
주파수는 7ms로 설정됩니다. 즉, 7ms가 실행될 때마다
계속하기 전에 I / O 및 완료 될 때까지 기다리십시오. 그 시점에서
스케줄러는 작업 1로 전환되며 I / O를 실행하기 전에 2ms 만 실행됩니다.
스케줄러는 이러한 방식으로 전체 실행 추적을 인쇄합니다.
마지막으로 각 작업에 대한 응답 및 처리 시간을 계산합니다.
뿐만 아니라 평균.

시뮬레이션의 다른 여러 측면을 제어 할 수도 있습니다. 예를 들어
시스템에 갖고 싶은 큐 수 (-n)와
양자 길이는 모든 대기열에 대해 있어야합니다 (-q). 더 원한다면
대기열 당 제어 및 다양한 퀀타 길이를 대신하여 길이를 지정할 수 있습니다.
-Q를 갖는 각 큐에 대한 양자 (타임 슬라이스)의 것, 예를 들어 -Q 10,20,30]
우선 순위가 가장 높은 큐가있는 세 개의 큐로 스케줄러를 시뮬레이션합니다.
10ms 타임 슬라이스, 그 다음으로 가장 높은 20ms 타임 슬라이스 및
우선 순위가 낮은 큐는 30ms 시간 조각입니다.

대기열 당 할당 시간을 개별적으로 제어 할 수 있습니다
너무. -a를 사용하거나 -A를 사용하여 큐당 모든 큐에 대해 설정할 수 있습니다 (예 : -A).
20,40,60은 대기열 당 시간 할당량을 20ms, 40ms 및 60ms로 설정합니다.
각기.

임의로 작업을 생성하는 경우 작업 시간을 제어 할 수도 있습니다
(-m) 동안 실행되거나 얼마나 자주 I / O를 생성하는지 (-M) 그러나 당신이 더 원한다면
시스템에서 실행중인 작업의 정확한 특성을 제어 할 수 있습니다.
-l (소문자 L) 또는 --jlist를 사용하여 정확한 값을 지정할 수 있습니다.
시뮬레이션하려는 작업 세트. 목록은 다음과 같은 형식입니다.
x1, y1, z1 : x2, y2, z2 : ... 여기서 x는 작업의 시작 시간이고 y는 실행 시간입니다.
(즉, 필요한 CPU 시간) 및 z I / O 주파수 (즉, 이후
z ms를 실행하면 작업이 I / O를 발행합니다. z가 0이면 I / O가 발행되지 않습니다.

예를 들어, 그림 8.3의 예제를 다시 작성하려는 경우
다음과 같이 작업 목록을 지정하십시오.

프롬프트> ./mlfq.py --jlist 0,180,0 : 100,20,0 -q 10

이런 방식으로 시뮬레이터를 실행하면 각 레벨마다 3 단계 MLFQ가 생성됩니다.
10ms 타임 슬라이스를 가지고 있습니다. 시간 0에서 시작하는 작업 0,
총 180ms 동안 실행되며 I / O를 발행하지 않습니다. 작업 1은 100ms에서 시작하여 필요
완료하는 데 20ms의 CPU 시간 만이 필요하며 I / O도 발행하지 않습니다.

마지막으로, 관심있는 파라미터가 세 개 더 있습니다. -B 플래그
0이 아닌 값, 모든 작업을 N마다 가장 높은 우선 순위 큐로 부스트
다음과 같이 호출 될 때 밀리 초 :
  프롬프트> ./mlfq.py -B N
스케줄러는이 기능을 사용하여
장. 그러나 기본적으로 해제되어 있습니다.

-S 플래그는 이전 규칙 4a 및 4b를 호출합니다. 이는 작업이
타임 슬라이스를 완료하기 전에 I / O가 동일한 우선 순위로 돌아갑니다.
전체 타임 슬라이스를 그대로 유지하면서 실행이 재개 될 때까지 대기합니다. 이
스케줄러의 게임을 가능하게합니다.

마지막으로 -i 플래그를 사용하여 I / O 지속 시간을 쉽게 변경할 수 있습니다. 으로
이 단순한 모델에서는 기본적으로 각 I / O의 고정 시간이 5입니다.
밀리 초 또는이 플래그로 설정 한 모든 것.

I / O를 완료 한 작업이 이동되었는지 여부를 확인할 수도 있습니다.
-I 플래그를 사용하여 큐의 헤드 또는 뒷면에 있습니다. 검사
그것은 재미있다!